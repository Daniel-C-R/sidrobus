"""Page for preprocessing data."""

import io

import pandas as pd
import streamlit as st

from sidrobus.preprocessing.filter_altitude import gaussian_filter, savgol_filter_route
from sidrobus.preprocessing.kml_to_dataframe import kml_to_dataframe
from sidrobus.preprocessing.preprocess_matlab_csv import preprocess_matlab


def main() -> None:
    """Main function for the preprocessing page."""
    st.title("üìä Data Preprocessing")
    st.markdown(
        """
        This page allows you to preprocess data from different sources:
        - **KML Files**: Convert GPS KML files to CSV format
        - **MATLAB Data**: Convert CSV files generated by MATLAB
        - **Altitude Filtering**: Apply filters to existing CSV data
        """
    )

    # Main navigation tabs
    tab1, tab2, tab3 = st.tabs(
        ["Convert KML to CSV", "Process MATLAB Data", "Filter CSV Altitude"]
    )

    with tab1:
        convert_kml_to_csv()
    with tab2:
        process_matlab_data()
    with tab3:
        filter_csv_altitude()


def process_matlab_data() -> None:
    """Process MATLAB CSV data."""
    st.header("üîß Process MATLAB Data")
    st.markdown(
        """
        Upload a CSV file generated by MATLAB. The preprocessing will convert
        the 'Timestamp' column to relative time in seconds.
        """
    )

    with st.form("matlab_form"):
        uploaded_file = st.file_uploader(
            "Select MATLAB CSV file",
            type=["csv"],
            help="The file must contain a 'Timestamp' column",
        )

        submitted = st.form_submit_button("Process Data")

    if submitted and uploaded_file is not None:
        try:
            # Read the CSV file
            matlab_data = pd.read_csv(uploaded_file)

            # Check if Timestamp column exists
            if "Timestamp" not in matlab_data.columns:
                st.error(
                    "The file does not contain a 'Timestamp' column. "
                    "Please verify it's a valid MATLAB file."
                )
                return

            # Preprocess MATLAB data
            with st.spinner("Processing MATLAB data..."):
                processed_data = preprocess_matlab(matlab_data)

            # Store processed data in session state
            st.session_state.matlab_processed_data = processed_data
            st.session_state.matlab_processing_done = True

        except Exception as e:
            st.error(f"Error processing data: {e}")
            return

    # Display results if data has been processed
    if (
        hasattr(st.session_state, "matlab_processing_done")
        and st.session_state.matlab_processing_done
    ):
        processed_data = st.session_state.matlab_processed_data

        st.success("Data processed successfully!")

        # Display results
        display_data_info(processed_data, "Processed Data")

        # Download button (outside the form)
        csv_buffer = io.StringIO()
        processed_data.to_csv(csv_buffer, index=False)
        csv_string = csv_buffer.getvalue()

        filename = "matlab_processed.csv"

        st.download_button(
            label="üì• Download Processed Data",
            data=csv_string,
            file_name=filename,
            mime="text/csv",
        )


def convert_kml_to_csv() -> None:
    """Convert KML file to CSV format."""
    st.header("üó∫Ô∏è Convert KML to CSV")
    st.markdown(
        """
        Upload a KML file with GPS data. Coordinates, times, and speeds will be
        extracted to create a compatible CSV file.
        """
    )

    with st.form("kml_form"):
        uploaded_file = st.file_uploader(
            "Select KML file",
            type=["kml"],
            help="KML file with GPS track data",
        )

        submitted = st.form_submit_button("Convert KML")

    if submitted and uploaded_file is not None:
        try:
            # Read KML content
            kml_content = uploaded_file.read().decode("utf-8")

            # Convert KML to DataFrame
            with st.spinner("Converting KML to CSV..."):
                csv_data = kml_to_dataframe(kml_content)

            # Store converted data in session state
            st.session_state.kml_converted_data = csv_data
            st.session_state.kml_conversion_done = True

        except Exception as e:
            st.error(f"Error converting KML: {e}")
            return

    # Display results if data has been converted
    if (
        hasattr(st.session_state, "kml_conversion_done")
        and st.session_state.kml_conversion_done
    ):
        csv_data = st.session_state.kml_converted_data

        st.success("KML converted successfully!")

        # Display results
        display_data_info(csv_data, "Converted Data")

        # Download button (outside the form)
        csv_buffer = io.StringIO()
        csv_data.to_csv(csv_buffer, index=False)
        csv_string = csv_buffer.getvalue()

        filename = "kml_converted.csv"

        st.download_button(
            label="üì• Download Converted CSV",
            data=csv_string,
            file_name=filename,
            mime="text/csv",
        )


def filter_csv_altitude() -> None:  # noqa: PLR0915
    """Filter altitude data in an existing CSV file."""
    st.header("üîç Filter CSV Altitude")
    st.markdown(
        """
        Upload an existing CSV file to apply altitude filters.
        The file must contain an 'altitude' column.
        """
    )

    # Filter configuration outside the form to allow dynamic updates
    st.subheader("Filter Configuration")
    filter_type = st.selectbox(
        "Filter type:", ["Savitzky-Golay", "Gaussian"], key="filter_type"
    )

    # Dynamic parameter inputs based on filter type
    if filter_type == "Savitzky-Golay":
        col1, col2 = st.columns(2)
        with col1:
            window_length = st.number_input(
                "Window length",
                min_value=0,
                max_value=1000,
                value=0,  # 0 = automatic (1/10 of data length)
                help="Window length for the filter. "
                "0 = automatic (1/10 of data length)",
                key="filter_window",
            )
        with col2:
            polyorder = st.number_input(
                "Polynomial order",
                min_value=1,
                max_value=10,
                value=2,
                key="filter_poly",
            )
    else:  # Gaussian
        sigma = st.number_input(
            "Sigma (standard deviation)",
            min_value=0.1,
            max_value=1000.0,
            value=2.0,
            step=0.1,
            key="filter_sigma",
        )

    with st.form("filter_form"):
        uploaded_file = st.file_uploader(
            "Select CSV file",
            type=["csv"],
            help="The file must contain an 'altitude' column",
        )

        submitted = st.form_submit_button("Apply Filter")

    if submitted and uploaded_file is not None:
        try:
            # Read the CSV file
            data = pd.read_csv(uploaded_file)

            # Check if altitude column exists
            if "altitude" not in data.columns:
                st.error(
                    "The file does not contain an 'altitude' column. "
                    "Available columns: " + ", ".join(data.columns)
                )
                return

            # Get filter parameters from session state
            filter_type = st.session_state.get("filter_type", "Savitzky-Golay")

            # Apply the selected filter
            with st.spinner("Applying filter..."):
                if filter_type == "Savitzky-Golay":
                    window_length = st.session_state.get("filter_window", 0)
                    polyorder = st.session_state.get("filter_poly", 2)
                    if window_length <= 0:
                        window_length = max(11, data.shape[0] // 10)
                    filtered_data = savgol_filter_route(
                        data, window_length=window_length, polyorder=polyorder
                    )
                else:  # Gaussian
                    sigma = st.session_state.get("filter_sigma", 2.0)
                    filtered_data = gaussian_filter(data, sigma=sigma)

            # Store filtered data in session state
            st.session_state.filtered_data = filtered_data
            st.session_state.original_data = data
            st.session_state.filter_type_applied = filter_type
            st.session_state.filtering_done = True

        except Exception as e:
            st.error(f"Error filtering data: {e}")
            return

    # Display results if data has been filtered
    if hasattr(st.session_state, "filtering_done") and st.session_state.filtering_done:
        filtered_data = st.session_state.filtered_data
        data = st.session_state.original_data
        filter_type = st.session_state.filter_type_applied

        st.success("Filter applied successfully!")

        # Display comparison with themed colors and synchronized Y-axis
        # Calculate common Y-axis range
        min_altitude = min(data["altitude"].min(), filtered_data["altitude"].min())
        max_altitude = max(data["altitude"].max(), filtered_data["altitude"].max())

        col1, col2 = st.columns(2)
        with col1:
            st.subheader("Original Data")
            # Add invisible points to force Y-axis range
            chart_data = data[["altitude"]].copy()
            chart_data.loc[len(chart_data)] = min_altitude
            chart_data.loc[len(chart_data)] = max_altitude
            chart_data.columns = ["Original Altitude"]
            st.line_chart(chart_data, color=["#8B4513"])

        with col2:
            st.subheader("Filtered Data")
            # Add invisible points to force Y-axis range
            chart_data = filtered_data[["altitude"]].copy()
            chart_data.loc[len(chart_data)] = min_altitude
            chart_data.loc[len(chart_data)] = max_altitude
            chart_data.columns = ["Filtered Altitude"]
            st.line_chart(chart_data, color=["#2C5E36"])

        # Display data info
        display_data_info(filtered_data, "Filtered Data")

        # Download button (outside the form)
        csv_buffer = io.StringIO()
        filtered_data.to_csv(csv_buffer, index=False)
        csv_string = csv_buffer.getvalue()

        filter_suffix = "savgol" if filter_type == "Savitzky-Golay" else "gaussian"
        filename = f"data_filtered_{filter_suffix}.csv"

        st.download_button(
            label="üì• Download Filtered Data",
            data=csv_string,
            file_name=filename,
            mime="text/csv",
        )


def display_data_info(data: pd.DataFrame, title: str) -> None:
    """Display information about the processed data."""
    st.subheader(title)

    st.metric("Number of rows", len(data))

    # Show data preview
    with st.expander("View data preview"):
        st.dataframe(data)


if __name__ == "__main__":
    main()
